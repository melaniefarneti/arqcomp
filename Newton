// prj.s
// Arqui I UCC

.text
.global main

main:
    LDR R3, =bolitaFija   ; Cargar la dirección de bolitaFija en R3
    LDRB R0, [R3]         ; Cargar el valor de bolitaFija en R0

    LDR R4, =bolitaMovil  ; Cargar la dirección de bolitaMovil en R4
    LDRB R1, [R4]         ; Cargar el valor de bolitaMovil en R1

    MOVS R5, #1           ; Configurar el valor inicial de direccionDerecha en R5
    MOVS R6, #0           ; Configurar el valor inicial de posicionMovil en R6

loop:
    CMP R5, #1            ; Comprobar si direccionDerecha es igual a 1
    BEQ move_right        ; Saltar a move_right si es igual a 1

move_left:
    SUBS R6, R6, #1       ; Decrementar posicionMovil en 1

    CMP R6, #0            ; Comprobar si posicionMovil es igual a 0
    BNE print_line        ; Saltar a print_line si no es igual a 0

    MOVS R5, #1           ; Establecer direccionDerecha en 1 para moverse hacia la derecha
    B loop                ; Volver al inicio del bucle

move_right:
    ADDS R6, R6, #1       ; Incrementar posicionMovil en 1

    CMP R6, #6            ; Comprobar si posicionMovil es igual a 6
    BNE print_line        ; Saltar a print_line si no es igual a 6

    MOVS R5, #0           ; Establecer direccionDerecha en 0 para moverse hacia la izquierda
    B loop                ; Volver al inicio del bucle

print_line:
    MOV R7, #0x5F         ; Cargar el valor ASCII de '_'
    STRB R7, [SP]         ; Almacenar el valor en la pila

    CMP R6, #3            ; Comprobar si posicionMovil es igual a 3
    BNE print_movil       ; Saltar a print_movil si no es igual a 3

    LDR R7, =bolitaFija   ; Cargar la dirección de bolitaFija en R7
    LDRB R7, [R7]         ; Cargar el valor de bolitaFija en R7
    STRB R7, [SP]         ; Almacenar el valor en la pila
    B next_char           ; Saltar a next_char

print_movil:
    LDR R7, =bolitaMovil  ; Cargar la dirección de bolitaMovil en R7
    LDRB R7, [R7]         ; Cargar el valor de bolitaMovil en R7

next_char:
    STRB R7, [SP, R6]     ; Almacenar el valor en la posición actual de la línea

    ADDS R6, R6, #1       ; Incrementar el contador de posición

    CMP R6, #7            ; Comprobar si se ha impreso toda la línea
    BNE next_char         ; Saltar a next_char si no se ha impreso toda la línea

    LDR R0, =7            ; Cargar la longitud de la línea
    LDR R1, =SP           ; Cargar la dirección base de la línea

    BL printf             ; Llamar a la función printf para imprimir la línea

    BL usleep             ; Llamar a la función usleep para esperar 100 milisegundos

    B loop                ; Volver al inicio del bucle

done:
    NOP            // dummy instruction for breakpoint
    MOV PC,L       // return from main

bolitaFija: .asciz "*"
bolitaMovil: .asciz "*"

.end

