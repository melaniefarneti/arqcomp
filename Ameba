.text
.global main

main:
    LDR R0, =ameba         ; Cargar la dirección base de ameba en R0
    LDR R1, =17            ; Cargar el tamaño de ameba en R1

    MOV R2, #128           ; Configurar el valor inicial de t en R2

loop:
    CMP R2, #0             ; Comprobar si t es igual a 0
    BEQ done               ; Salir del bucle si es igual a 0

    ANDS R3, R0, R2        ; Realizar la operación lógica AND entre i y t y almacenar el resultado en R3
    CMP R3, #0             ; Comprobar si el resultado de la operación AND es igual a 0
    BEQ print_underscore   ; Saltar a print_underscore si es igual a 0

print_asterisk:
    LDR R4, =42            ; Cargar el valor ASCII de '*' en R4
    STRB R4, [SP]          ; Almacenar el valor en la pila

    B next_char            ; Saltar a next_char

print_underscore:
    LDR R4, =95            ; Cargar el valor ASCII de '_' en R4
    STRB R4, [SP]          ; Almacenar el valor en la pila

next_char:
    ADDS R0, R0, #1        ; Incrementar la dirección base de ameba
    SUBS R1, R1, #1        ; Decrementar el contador de tamaño

    CMP R1, #0             ; Comprobar si se ha impreso toda la línea
    BNE next_char          ; Saltar a next_char si no se ha impreso toda la línea

    MOV R0, #10            ; Cargar el valor ASCII de salto de línea en R0
    BL putchar             ; Llamar a la función putchar para imprimir el salto de línea

    LSRS R2, R2, #1        ; Dividir t por 2

    B loop                 ; Volver al inicio del bucle

done:
    NOP            // dummy instruction for breakpoint
    MOV PC,L       // return from main


ameba:  .byte 0x81, 0x41, 0x21, 0x11, 0x09, 0x05, 0x83, 0x83, 0x8C, 0x98, 0xB0, 0xE0, 0xE1, 0x71, 0x39, 0x1D, 0x0F

.end
